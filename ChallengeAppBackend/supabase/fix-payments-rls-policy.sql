-- Исправление RLS политик для таблицы payments
-- Выполните этот SQL в Supabase SQL Editor
-- 
-- Проблема: При пополнении баланса возникает ошибка 
-- "new row violates row-level security policy for table payments"
-- 
-- Причина: В таблице payments включен RLS, но нет политики для INSERT
-- 
-- Решение: Добавить политику, позволяющую пользователям создавать свои записи о платежах

-- Проверяем, включен ли RLS (должен быть включен)
ALTER TABLE public.payments ENABLE ROW LEVEL SECURITY;

-- Удаляем политику, если она уже существует (для повторного запуска)
DROP POLICY IF EXISTS "Users can insert own payments" ON public.payments;

-- Создаем политику для INSERT: пользователи могут создавать записи о своих платежах
CREATE POLICY "Users can insert own payments"
    ON public.payments FOR INSERT
    WITH CHECK (auth.uid() = user_id);

-- ============================================
-- ВАЖНО: Политика UPDATE НЕ НУЖНА
-- ============================================
-- 
-- Политика UPDATE для пользователей НЕ требуется, потому что:
-- 
-- 1. БЕЗОПАСНОСТЬ:
--    - Пользователи не должны напрямую изменять статус своих платежей
--    - Это может привести к мошенничеству (например, изменение статуса на COMPLETED без реальной оплаты)
-- 
-- 2. АРХИТЕКТУРА:
--    - Все обновления платежей происходят через Edge Functions (payment-webhook)
--    - Edge Functions используют service_role ключ, который обходит RLS
--    - Статусы обновляются автоматически при получении webhook от платежной системы
-- 
-- 3. ТЕКУЩАЯ РЕАЛИЗАЦИЯ:
--    - depositBalance() - только создает записи (INSERT), не обновляет
--    - withdrawBalance() - только создает записи (INSERT), не обновляет
--    - payment-webhook Edge Function - обновляет статусы (использует service_role)
-- 
-- Если в будущем понадобится, чтобы пользователи могли отменять свои платежи,
-- лучше создать отдельную Edge Function для этого, а не давать прямой доступ к UPDATE.

-- Проверка: после выполнения этого скрипта пополнение баланса должно работать
-- 
-- Примечание: 
-- - auth.uid() возвращает UUID текущего авторизованного пользователя
-- - user_id в таблице payments имеет тип UUID, поэтому сравниваем напрямую (оба UUID)
-- - WITH CHECK проверяет, что user_id в новой записи совпадает с auth.uid()
